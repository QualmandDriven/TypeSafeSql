sqlDialect=SQLite
;Directory=C:\Users\Alexander\Source\Repos\TypeSafeSql\src\TypeProofSql
Directory=..\..\..\..\TypeProofSql

[COMMON_CLASSES]
SQLiteDSLContext = SQLiteDSLContext
ConditionalGroupStatement = ConditionalGroupStatement
ConditionalStatement = ConditionalStatement

[CLASSES]
Not = Not

With = With
WithTable = WithTable(ITable table, ISelectColumn[] selectColumns)
WithTable<T> = WithTable<T>(ISelectColumn[] selectColumns) : WithTable(new T(), selectColumns)
WithTableAdditional = WithTableAdditional(ITable table, ISelectColumn[] selectColumns)
WithTableAdditional<T> = WithTableAdditional<T>(ISelectColumn[] selectColumns) : WithTableAdditional(new T(), selectColumns)
Recursive = Recursive(ITable table, ISelectColumn[] selectColumns)
Recursive<T> = Recursive<T>(ISelectColumn[] selectColumns) : Recursive(new T(), selectColumns)

Materialized = Materialized(IQueryBuilder subQuery)

WithAs = WithAs
WithNot = WithNot

As = As
AsSelect = AsSelect(IQueryBuilder subQuery)
WithAsSelect = WithAsSelect(ITable table, IQueryBuilder subQuery)
WithAsSelect<T> = WithAsSelect<T>(IQueryBuilder subQuery) : WithAsSelect(new T(), subQuery)


All = All

Select = Select
SelectColumns = SelectColumns(ISelectColumn[] columns)
Distinct = Distinct
DistinctColumns = DistinctColumns(ISelectColumn[] columns)

From = From(ITable table)
FromSubQuery = FromSubQuery(IQueryBuilder subQueryBuilder, ITable table)
From<T> = From<T>() : From(new T())
FromSubQuery<T> = FromSubQuery<T>(IQueryBuilder subQueryBuilder) : FromSubQuery(subQueryBuilder, new T())

TableAs = TableAs(string alias)

Join = Join(ITable left, ITable right)
Join<T, J> = Join<T, J>(T left, J right) : Join(left, right)
JoinSubQuery = JoinSubQuery(IQueryBuilder subQueryBuilder)
JoinAs = JoinAs(string alias)
;ConditionalJoin<T, J> = ConditionalJoin<T, J>((ISelectColumn<T> col1, ISelectColumn<J> col2)[] on) : Join<T, J>(new T(), new J())
;NonConditionalJoin = NonConditionalJoin(ITable left, ITable right) : Join(left, right)
;NonConditionalJoin<T, J> = NonConditionalJoin<T, J>() : NonConditionalJoin(new T(), new J())
;CrossJoin<T, J> = CrossJoin<T, J>() : NonConditionalJoin<T, J>()
;FullOuterJoin<T, J> = FullOuterJoin<T, J>((ISelectColumn<T> col1, ISelectColumn<J> col2)[] on) : ConditionalJoin<T, J>(on)
;InnerJoin<T, J> = InnerJoin<T, J>((ISelectColumn<T> col1, ISelectColumn<J> col2)[] on) : ConditionalJoin<T, J>(on)
;LeftOuterJoin<T, J> = LeftOuterJoin<T, J>((ISelectColumn<T> col1, ISelectColumn<J> col2)[] on) : ConditionalJoin<T, J>(on)
;RightOuterJoin<T, J> = RightOuterJoin<T, J>((ISelectColumn<T> col1, ISelectColumn<J> col2)[] on) : ConditionalJoin<T, J>(on)
ConditionalJoin<T, J> = ConditionalJoin<T, J>() : Join<T, J>(new T(), new J())
NonConditionalJoin = NonConditionalJoin(ITable left, ITable right) : Join(left, right)
NonConditionalJoin<T, J> = NonConditionalJoin<T, J>() : NonConditionalJoin(new T(), new J())
CrossJoin<T, J> = CrossJoin<T, J>() : NonConditionalJoin<T, J>()
FullOuterJoin<T, J> = FullOuterJoin<T, J>() : ConditionalJoin<T, J>()
InnerJoin<T, J> = InnerJoin<T, J>() : ConditionalJoin<T, J>()
LeftOuterJoin<T, J> = LeftOuterJoin<T, J>() : ConditionalJoin<T, J>()
RightOuterJoin<T, J> = RightOuterJoin<T, J>() : ConditionalJoin<T, J>()

On = On(ISelectColumn left, ISelectColumn right)
OnMulti = OnMulti((ISelectColumn left, ISelectColumn right) on)
On<T, J> = On<T, J>(ISelectColumn<T> left, ISelectColumn<J> right) : On(left, right)
OnMulti<T, J> = OnMulti<T, J>((ISelectColumn<T> left, ISelectColumn<J> right) on)

WhereGroup = WhereGroup(ConditionalGroupStatement groupExpr)
Where = Where(ConditionalExpression conditionalExpression) : ConditionalGroup
And = And(ConditionalGroupStatement groupStatement, ConditionalExpression conditionalExpression) : Conditional(groupStatement, conditionalExpression)
AndGroup = AndGroup(ConditionalExpression conditionalExpression) : ConditionalGroup(conditionalExpression)
Or = Or(ConditionalGroupStatement groupStatement, ConditionalExpression conditionalExpression) : Conditional(groupStatement, conditionalExpression)
OrGroup = OrGroup(ConditionalExpression conditionalExpression) : ConditionalGroup(conditionalExpression)

Having = Having(ConditionalExpression conditionalExpression) : ConditionalGroup(conditionalExpression)

GroupBy = GroupBy(IColumn[] groupByColumns)
OrderBy = OrderBy(IOrderByColumn[] orderByColumns)
Collate = Collate
Asc = Asc
Desc = Desc
Nulls = Nulls
First = First
Last = Last

Limit = Limit(int limit)
Offset = Offset(int offset)

Insert = Insert
Replace = Replace
InsertOr = InsertOr
Abort = Abort
Fail = Fail
Ignore = Ignore
Rollback = Rollback
Into = Into(ITable table)
Into<T> = Into<T>() : Into(new T())
IntoAs = IntoAs(string alias)

InsertSelect = InsertSelect(ISelectColumn[] columns)
InsertSelect<T> = InsertSelect<T>(ISelectColumn<T>[] columns) : InsertSelect(columns)
InsertValues = InsertValues(ValueExpression[] valueExpressions)

Default = Default
DefaultValues = DefaultValues

Update = Update(ITable table)
Update<T> = Update<T>() : Update(new T())

UpdateSet = UpdateSet(ITable table, ValueExpression[] valueExpressions)
UpdateSet<T> = UpdateSet<T>(ValueExpression[] valueExpressions) : UpdateSet(new T(), valueExpressions)
UpdateOr = UpdateOr(ITable table)
UpdateOr<T> = UpdateOr<T>() : UpdateOr(new T())

UpdateAbort = UpdateAbort(ITable table)
UpdateAbort<T> = UpdateAbort<T>() : UpdateAbort(new T())
UpdateFail = UpdateFail(ITable table)
UpdateFail<T> = UpdateFail<T>() : UpdateAbort(new T())
UpdateIgnore = UpdateIgnore(ITable table)
UpdateIgnore<T> = UpdateIgnore<T>() : UpdateAbort(new T())
UpdateReplace = UpdateReplace(ITable table)
UpdateReplace<T> = UpdateReplace<T>() : UpdateAbort(new T())
UpdateRollback = UpdateRollback(ITable table)
UpdateRollback<T> = UpdateRollback<T>() : UpdateAbort(new T())

UpdateFrom = UpdateFrom(ITable table)
UpdateFrom<T> = UpdateFrom<T>() : UpdateFrom(new T())
UpdateWhere = UpdateWhere

UpdateConditionalJoin<T, J> = UpdateConditionalJoin<T, J>() : ConditionalJoin<T, J>()

UpsertOn = UpsertOn
Conflict = Conflict
UpsertDo = UpsertDo
UpsertNothing = UpsertNothing
UpsertUpdate = UpsertUpdate
UpsertSet = UpsertSet
UpsertWhere = UpsertWhere
UpsertOn = UpsertOn

Returning = Returning
ReturningSelect = ReturningSelect(ISelectColumn[] columns)
ReturningSelect<T> = ReturningSelect<T>(ISelectColumn<T>[] columns) : InsertSelect(columns)
ReturningAll = ReturningAll

Delete = Delete
DeleteFrom = DeleteFrom(ITable table)
DeleteFrom<T> = DeleteFrom<T>() : DeleteFrom(new T())
DeleteWhere = DeleteWhere
DeleteWhereGroup = DeleteWhereGroup

Set = Set(ValueExpression[] valueExpressions)
Value = Value(ValueExpression[] valueExpressions)


Compound = Compound(IQueryBuilder subQueryBuilder)
Union = Union(IQueryBuilder subQueryBuilder) : Compound(subQueryBuilder)
UnionAll = UnionAll(IQueryBuilder subQueryBuilder) : Compound(subQueryBuilder)
Intersect = Intersect(IQueryBuilder subQueryBuilder) : Compound(subQueryBuilder)
Except = Except(IQueryBuilder subQueryBuilder) : Compound(subQueryBuilder)

[CHAINING]
;With = _COMMON_TBL_EXPR_
;With<T>
With = SQLiteDSLContext : With; SQLiteDSLContext : WithTable<T>; AsSelect : WithTableAdditional<T>; Materialized : WithTableAdditional<T>
Recursive = With : Recursive<T>
;Recursive = _COMMON_TBL_EXPR_

Materialized = As : Materialized; Not : Materialized; WithTable : Materialized; WithTableAdditional : Materialized

Not = As : Not; AsSelect : Not

Select = SQLiteDSLContext : Select; SQLiteDSLContext : SelectColumns; AsSelect : Select; AsSelect : SelectColumns; Materialized : Select; Materialized : SelectColumns; Compound : Select; Compound : SelectColumns
All = Select : All; Distinct : All
Distinct = SelectColumns : Distinct; Select : DistinctColumns; Select : Distinct
From = Select : From<T>; SelectColumns : From<T>; DistinctColumns : From<T>; All : From<T>; Delete : From<T>
As = From : TableAs; Join : JoinAs; Recursive : AsSelect; WithTable : AsSelect; WithTableAdditional : AsSelect; Recursive : As; WithTable : As

InnerJoin = From : InnerJoin<T, J>; NonConditionalJoin : InnerJoin<T, J>
LeftJoin = From : LeftOuterJoin<T, J>; NonConditionalJoin : LeftOuterJoin<T, J>
RightJoin = From : RightOuterJoin<T, J>; NonConditionalJoin : RightOuterJoin<T, J>
FullJoin = From : FullOuterJoin<T, J>; NonConditionalJoin : FullOuterJoin<T, J>
CrossJoin = From : CrossJoin<T, J>; NonConditionalJoin : CrossJoin<T, J>

On = Join : On<T, J>; Join : OnMulti<T, J>; JoinAs : On<T, J>; JoinAs : OnMulti<T, J>; ConditionalJoin<T, J> : On<T, J>; ConditionalJoin<T, J> : OnMulti<T, J>

;Where
WhereGroup = From : ConditionalGroupStatement; On : ConditionalGroupStatement; OnMulti : ConditionalGroupStatement; NonConditionalJoin : ConditionalGroupStatement


GroupBy = From : GroupBy; ConditionalGroupStatement : GroupBy

Having = GroupBy : Having; Where : Having

Limit = From : Limit; GroupBy : Limit; OrderBy : Limit; Where : Limit
;Conditional : Limit; ConditionalGroup : Limit
Offset = Limit : Offset

OrderBy = From : OrderBy; GroupBy : OrderBy; Where : OrderBy
;Conditional : OrderBy; ConditionalGroup : OrderBy

Insert = SQLiteDSLContext : Insert
Into = Insert : Into<T>
Values = Into : Value

Update = SQLiteDSLContext : Update<T>
Set = Update : Set

Delete = SQLiteDSLContext : Delete

UnionAll = From : UnionAll